
'use server';
/**
 * @fileOverview AI flows for the Questions Creator feature.
 *
 * - generateQuestions - Generates questions based on document content.
 * - convertQuestionsToJson - Converts text-based questions to a structured JSON format.
 * - repairJson - Attempts to repair a malformed JSON string.
 */

import { ai } from '@/ai/genkit';
import { z } from 'genkit';
import type { Lecture } from '@/lib/types';

// Schema for generating questions
const GenerateQuestionsInputSchema = z.object({
  prompt: z.string().describe('The user-defined prompt for generating questions.'),
  documentContent: z.string().describe('The text content extracted from the uploaded document.'),
  images: z.array(z.string()).describe("A list of images from the document, as data URIs. Expected format: 'data:<mimetype>;base64,<encoded_data>'."),
});
export type GenerateQuestionsInput = z.infer<typeof GenerateQuestionsInputSchema>;

// Schema for converting questions to JSON
const ConvertToJsonInputSchema = z.object({
  lectureName: z.string().describe("The name of the lecture, for example 'L1 Blood'."),
  questionsText: z.string().describe('The text of the questions generated by the first model, which includes MCQs and written cases.'),
});
export type ConvertToJsonInput = z.infer<typeof ConvertToJsonInputSchema>;


// Schema for repairing JSON
const RepairJsonInputSchema = z.object({
  malformedJson: z.string().describe('The malformed JSON string that needs to be repaired.'),
  desiredSchema: z.string().describe('A description or schema of the desired JSON structure.'),
});
export type RepairJsonInput = z.infer<typeof RepairJsonInputSchema>;


const generateQuestionsPrompt = ai.definePrompt({
    name: 'generateQuestionsPrompt',
    input: { schema: GenerateQuestionsInputSchema },
    prompt: `
        You are an expert at creating educational material from documents.
        Follow the user's instructions precisely to generate questions from the provided document content, which includes text and images.
        Base your questions on both the text and the visual information in the images.
        Use clear separators like '---' between different sections (e.g., between Level 1 MCQs and Level 2 MCQs).

        USER'S PROMPT:
        {{{prompt}}}

        DOCUMENT CONTENT (TEXT):
        {{{documentContent}}}

        DOCUMENT CONTENT (IMAGES):
        {{#each images}}
        {{media url=this}}
        {{/each}}
    `,
});

const isRetriableError = (error: any): boolean => {
    const errorMessage = error.message?.toLowerCase() || '';
    const retriableStrings = ['500', '503', '504', 'overloaded', 'timed out', 'service unavailable'];
    return retriableStrings.some(s => errorMessage.includes(s));
};

async function runWithRetry<T>(fn: () => Promise<T>): Promise<T> {
  const maxRetries = 3;
  let delay = 1000;

  for (let i = 0; i < maxRetries; i++) {
    try {
      return await fn();
    } catch (error: any) {
      if (i === maxRetries - 1 || !isRetriableError(error)) {
        console.error(`Final attempt failed or non-retriable error: ${error.message}`);
        throw error;
      }
      console.log(`Attempt ${i + 1} failed. Retrying in ${delay}ms...`);
      await new Promise(res => setTimeout(res, delay));
      delay *= 2;
    }
  }
  throw new Error('Operation failed after multiple retries.');
}

export async function generateQuestions(input: GenerateQuestionsInput): Promise<string> {
    return runWithRetry(async () => {
        const { text } = await generateQuestionsPrompt(input);
        return text;
    });
}

// Programmatic reordering to guarantee final structure
function reorderAndStringify(obj: any): string {
    if (typeof obj === 'string') {
        try {
            obj = JSON.parse(obj);
        } catch (e) {
            return obj; // Return original string if it's not valid JSON
        }
    }
    if (typeof obj !== 'object' || obj === null) return '';

    const orderedKeys: (keyof Lecture)[] = ['id', 'name', 'mcqs_level_1', 'mcqs_level_2', 'written', 'flashcards'];
    const orderedObject: { [key: string]: any } = {};

    // Add known keys in the desired order
    for (const key of orderedKeys) {
        if (obj.hasOwnProperty(key)) {
            orderedObject[key] = obj[key];
        }
    }

    // Add any other keys that might exist (to prevent data loss)
    for (const key in obj) {
        if (!orderedObject.hasOwnProperty(key)) {
            orderedObject[key] = obj[key];
        }
    }
    
    const reorderMcqKeys = (mcqs: any[]) => {
      if (!Array.isArray(mcqs)) return mcqs;
      return mcqs.map(mcq => {
        if (typeof mcq !== 'object' || mcq === null) return mcq;
        const orderedMcq: {[key: string]: any} = {};
        if (mcq.hasOwnProperty('q')) orderedMcq.q = mcq.q;
        if (mcq.hasOwnProperty('o')) orderedMcq.o = mcq.o;
        if (mcq.hasOwnProperty('a')) orderedMcq.a = mcq.a;
        // Add any other keys to be safe
        Object.keys(mcq).forEach(key => {
          if (!orderedMcq.hasOwnProperty(key)) {
            orderedMcq[key] = mcq[key];
          }
        });
        return orderedMcq;
      });
    };

    if (orderedObject.mcqs_level_1) {
      orderedObject.mcqs_level_1 = reorderMcqKeys(orderedObject.mcqs_level_1);
    }
    if (orderedObject.mcqs_level_2) {
      orderedObject.mcqs_level_2 = reorderMcqKeys(orderedObject.mcqs_level_2);
    }

    if (orderedObject.written) {
        if (Array.isArray(orderedObject.written)) {
            orderedObject.written = orderedObject.written.map(w => {
                if (typeof w !== 'object' || w === null) return w;
                const orderedCase: {[key: string]: any} = {};
                if (w.hasOwnProperty('case')) orderedCase.case = w.case;
                if (w.hasOwnProperty('subqs')) {
                     orderedCase.subqs = Array.isArray(w.subqs) ? w.subqs.map((sq: any) => {
                        if (typeof sq !== 'object' || sq === null) return sq;
                        const orderedSubq: {[key: string]: any} = {};
                        if (sq.hasOwnProperty('q')) orderedSubq.q = sq.q;
                        if (sq.hasOwnProperty('a')) orderedSubq.a = sq.a;
                        Object.keys(sq).forEach(key => {
                            if(!orderedSubq.hasOwnProperty(key)) orderedSubq[key] = sq[key];
                        });
                        return orderedSubq;
                     }) : w.subqs;
                }
                Object.keys(w).forEach(key => {
                    if (!orderedCase.hasOwnProperty(key)) orderedCase[key] = w[key];
                });
                return orderedCase;
            });
        }
    }


    if (orderedObject.flashcards) {
        if(Array.isArray(orderedObject.flashcards)) {
            orderedObject.flashcards = orderedObject.flashcards.map(fc => {
                if (typeof fc !== 'object' || fc === null) return fc;
                const orderedFc: {[key: string]: any} = {};
                if (fc.hasOwnProperty('front')) orderedFc.front = fc.front;
                if (fc.hasOwnProperty('back')) orderedFc.back = fc.back;
                Object.keys(fc).forEach(key => {
                    if (!orderedFc.hasOwnProperty(key)) {
                        orderedFc[key] = fc[key];
                    }
                });
                return orderedFc;
            });
        }
    }


    return JSON.stringify(orderedObject, null, 2);
}


const convertToJsonPrompt = ai.definePrompt({
    name: 'convertToJsonPrompt',
    input: { schema: ConvertToJsonInputSchema },
    output: { format: 'json' },
    prompt: `
        You are a highly skilled text-to-JSON conversion engine. Your task is to convert the provided text of questions into a structured JSON object.
        The output MUST be a single, valid JSON object and nothing else.
        You MUST process the entire input text and include all questions provided.

        Follow this exact JSON structure:
        {
          "id": "A short, lowercase, URL-friendly ID derived from the lecture name (e.g., 'l1-blood').",
          "name": "The full lecture name, taken from the input.",
          "mcqs_level_1": [
            {
              "q": "The full question text, including the number.",
              "o": ["An array of strings, each representing one option."],
              "a": "The string of the correct option."
            }
          ],
          "mcqs_level_2": [
            // Same structure as mcqs_level_1
          ],
          "written": [
            {
              "case": "The full text of the clinical case description.",
              "subqs": [
                {
                  "q": "The sub-question text.",
                  "a": "The answer text for the sub-question. Preserve any HTML tags like <strong> if they exist in the source."
                }
              ]
            }
          ]
        }

        - The 'id' should be a unique, simplified version of the lecture name.
        - Split the MCQs into 'mcqs_level_1' and 'mcqs_level_2' based on the headings in the text.
        - For 'written' questions, group all sub-questions under their respective case.
        - Ensure all text, including questions, options, and answers, is captured exactly as it appears.
        - For each MCQ, the keys must be 'q', 'o', and 'a'.
        - For each written sub-question, the keys must be 'q' and 'a'.

        Lecture Name:
        {{{lectureName}}}

        Text to Convert:
        {{{questionsText}}}
    `,
});


export async function convertQuestionsToJson(input: ConvertToJsonInput): Promise<string> {
    return runWithRetry(async () => {
        try {
            const { output } = await convertToJsonPrompt(input);

            if (typeof output === 'object' && output !== null) {
                // Return the stringified JSON with guaranteed key order
                return reorderAndStringify(output);
            }
            
            // If the output is already a string, it might be malformed or correct.
            if (typeof output === 'string') {
                try {
                    const parsed = JSON.parse(output);
                    return reorderAndStringify(parsed);
                } catch(e) {
                     // If parsing fails, try to repair it.
                    console.warn("Initial JSON conversion produced a string that failed to parse. Attempting repair.");
                    const repairedJsonString = await repairJson({
                        malformedJson: output,
                        desiredSchema: "A JSON object with keys like 'id', 'name', 'mcqs_level_1', etc. containing ALL questions from the source."
                    });
                    const parsedRepaired = JSON.parse(repairedJsonString);
                    return reorderAndStringify(parsedRepaired);
                }
            }
            
            const errorMsg = `The AI returned a response that could not be converted to a valid JSON structure. Raw output: ${JSON.stringify(output)}`;
            throw new Error(errorMsg);

        } catch (err: any) {
            console.error("Error in convertQuestionsToJson flow:", err.message);
            // Attempt to repair if there's a JSON string in the error by re-processing the malformed output
            // This is the CRITICAL change: we repair the *output* of the model, not the original text.
             if (err.message.includes('JSON')) {
                try {
                     console.log("Attempting to repair JSON from the malformed model output.");
                     const malformedJson = err.message.substring(err.message.indexOf('{'), err.message.lastIndexOf('}') + 1) || input.questionsText;
                     const repairedJsonString = await repairJson({
                        malformedJson: malformedJson,
                        desiredSchema: "A JSON object with keys like 'id', 'name', 'mcqs_level_1', etc. containing ALL questions from the source."
                     });
                     const parsedRepaired = JSON.parse(repairedJsonString);
                     return reorderAndStringify(parsedRepaired);
                } catch (repairErr: any) {
                    console.error("JSON repair failed:", repairErr.message);
                    throw new Error("Failed to convert and repair the JSON content.");
                }
            }
            throw new Error(err.message || "An unexpected error occurred during JSON conversion.");
        }
    });
}


const repairJsonPrompt = ai.definePrompt({
    name: 'repairJsonPrompt',
    input: { schema: RepairJsonInputSchema },
    output: { format: 'json' },
    prompt: `
        You are a JSON repair expert. The following string is a malformed JSON.
        Fix it so that it perfectly matches the desired schema.
        The desired schema is: {{{desiredSchema}}}
        It is CRITICAL that you include ALL content from the original text. Do not truncate or omit any questions.

        Malformed JSON:
        {{{malformedJson}}}

        Your response MUST be only the corrected JSON content.
    `,
});

export async function repairJson(input: RepairJsonInput): Promise<string> {
     return runWithRetry(async () => {
        const { output } = await repairJsonPrompt(input);
        
        if (typeof output === 'object' && output !== null) {
            // The reorderAndStringify will be called by the parent function, 
            // but we can do it here too for direct calls.
            return reorderAndStringify(output);
        }
        
        if (typeof output === 'string') {
            try {
                const parsed = JSON.parse(output);
                return reorderAndStringify(parsed);
            } catch(e) {
                console.error("Repair process resulted in another invalid JSON string.");
                throw new Error('The repair process resulted in invalid JSON data.');
            }
        }
        
        throw new Error('The repair process resulted in an unexpected data type.');
    });
}




    

    
