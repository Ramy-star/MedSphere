
'use server';
/**
 * @fileOverview AI flows for the Questions Creator feature.
 *
 * - generateQuestions - Generates questions based on document content.
 * - convertQuestionsToJson - Converts text-based questions to a structured JSON format.
 */

import { ai } from '@/ai/genkit';
import { z } from 'genkit';

// --- Input Schemas ---

const GenerateTextInputSchema = z.object({
  prompt: z.string().describe('The user-defined prompt for generating questions.'),
  documentContent: z.string().describe('The text content extracted from the uploaded document.'),
  images: z.array(z.string()).optional().describe("A list of images from the document, as data URIs. Expected format: 'data:<mimetype>;base64,<encoded_data>'."),
});
export type GenerateTextInput = z.infer<typeof GenerateTextInputSchema>;

const ConvertQuestionsToJsonInputSchema = z.object({
  lectureName: z.string().describe("The name of the lecture, for example 'L1 Blood'."),
  questionsText: z.string().describe('The text of the questions generated by the first model, which includes MCQs and written cases.'),
});
export type ConvertQuestionsToJsonInput = z.infer<typeof ConvertQuestionsToJsonInputSchema>;

const ConvertFlashcardsToJsonInputSchema = z.object({
  lectureName: z.string().describe("The name of the lecture, for example 'L1 Blood'."),
  flashcardsText: z.string().describe('The text of the flashcards generated by the first model.'),
});
export type ConvertFlashcardsToJsonInput = z.infer<typeof ConvertFlashcardsToJsonInputSchema>;


// --- Retry Logic ---

const isRetriableError = (error: any): boolean => {
    const errorMessage = error.message?.toLowerCase() || '';
    const retriableStrings = ['500', '503', '504', 'overloaded', 'timed out', 'service unavailable', 'deadline exceeded'];
    return retriableStrings.some(s => errorMessage.includes(s));
};

async function runWithRetry<T>(fn: () => Promise<T>): Promise<T> {
  const maxRetries = 3; // Total attempts will be initial + 3 retries = 4
  let delay = 1000; // 1 second initial delay

  for (let i = 0; i < maxRetries; i++) {
    try {
      return await fn();
    } catch (error: any) {
      if (i === maxRetries - 1 || !isRetriableError(error)) {
        console.error(`Final attempt failed or non-retriable error: ${error.message}`);
        throw error;
      }
      console.log(`Attempt ${i + 1} failed. Retrying in ${delay}ms...`);
      await new Promise(res => setTimeout(res, delay));
      delay *= 2; // Exponential backoff
    }
  }
  // This line should not be reachable, but it satisfies TypeScript's requirement
  // that the function must return a value of type T or throw an error.
  throw new Error('Operation failed after multiple retries.');
}

// --- Text Generation Prompt ---

const generateTextPrompt = ai.definePrompt({
    name: 'generateTextPrompt',
    input: { schema: GenerateTextInputSchema },
    prompt: `
        You are an expert at creating educational material from documents.
        Follow the user's instructions precisely to generate content from the provided document text and images.
        Base your content on both the text and any visual information in the images.
        Use clear separators like '---' between different sections.

        USER'S PROMPT:
        {{{prompt}}}

        DOCUMENT CONTENT (TEXT):
        {{{documentContent}}}

        DOCUMENT CONTENT (IMAGES):
        {{#if images}}
          {{#each images}}
            {{media url=this}}
          {{/each}}
        {{/if}}
    `,
});

export async function generateText(input: GenerateTextInput): Promise<string> {
    return runWithRetry(async () => {
        const { text } = await generateTextPrompt(input);
        return text;
    });
}

// --- Questions/Exam JSON Conversion ---

const convertQuestionsToJsonPrompt = ai.definePrompt({
    name: 'convertQuestionsToJsonPrompt',
    input: { schema: ConvertQuestionsToJsonInputSchema },
    output: { format: 'json' },
    prompt: `
        You are a highly skilled text-to-JSON conversion engine. Your task is to convert the provided text of questions into a structured JSON object.
        The output MUST be a single, valid JSON object and nothing else.
        You MUST process the entire input text and include all questions provided.

        Follow this exact JSON structure:
        {
          "id": "A short, lowercase, URL-friendly ID derived from the lecture name (e.g., 'l1-blood').",
          "name": "The full lecture name, taken from the input.",
          "mcqs_level_1": [
            {
              "q": "The full question text, including the number.",
              "o": ["An array of strings, each representing one option."],
              "a": "The string of the correct option."
            }
          ],
          "mcqs_level_2": [
            // Same structure as mcqs_level_1
          ],
          "written": [
            {
              "case": "The full text of the clinical case description.",
              "subqs": [
                {
                  "q": "The sub-question text.",
                  "a": "The answer text for the sub-question. Preserve any HTML tags like <strong> if they exist in the source."
                }
              ]
            }
          ]
        }

        - The 'id' should be a unique, simplified version of the lecture name.
        - Split the MCQs into 'mcqs_level_1' and 'mcqs_level_2' based on the headings in the text.
        - For 'written' questions, group all sub-questions under their respective case.
        - Ensure all text, including questions, options, and answers, is captured exactly as it appears.
        - For each MCQ, the keys must be 'q', 'o', and 'a'.
        - For each written sub-question, the keys must be 'q' and 'a'.

        Lecture Name:
        {{{lectureName}}}

        Text to Convert:
        {{{questionsText}}}
    `,
});

// --- Flashcard JSON Conversion ---

const convertFlashcardsToJsonPrompt = ai.definePrompt({
  name: 'convertFlashcardsToJsonPrompt',
  input: { schema: ConvertFlashcardsToJsonInputSchema },
  output: { format: 'json' },
  prompt: `
      You are an expert text-to-JSON conversion engine. Convert the provided flashcard text into a structured JSON array of lecture objects.
      The output MUST be a single, valid JSON object representing one lecture and nothing else.

      Follow this exact JSON structure:
      {
        "id": "A short, lowercase, URL-friendly ID from the lecture name (e.g., 'l1-blood').",
        "name": "The full lecture name from the input.",
        "flashcards": [
          {
            "id": "A unique text identifier for the card (e.g., 'card-1', 'card-2').",
            "front": "The full text for the front of the card (the question).",
            "back": "The full text for the back of the card (the answer)."
          }
        ]
      }

      - The top-level object represents a single lecture.
      - The 'id' should be a simplified version of the lecture name.
      - The 'flashcards' property must be an array of objects.
      - Each flashcard object MUST have 'id', 'front', and 'back' keys.

      Lecture Name:
      {{{lectureName}}}

      Flashcard Text to Convert:
      {{{flashcardsText}}}
  `,
});

// --- JSON Conversion Main Function ---

async function convertContentToJson<T>(prompt: (input: T) => Promise<{ output: any }>, input: T): Promise<string> {
    return runWithRetry(async () => {
        const { output } = await prompt(input);

        if (typeof output === 'object' && output !== null) {
            return JSON.stringify(output, null, 2);
        }

        if (typeof output === 'string') {
            try {
                const parsed = JSON.parse(output);
                return JSON.stringify(parsed, null, 2);
            } catch (e) {
                console.error("The AI returned a string that is not valid JSON.", output);
                throw new Error("Failed to convert content to a valid JSON structure. Please check the generated text and try again.");
            }
        }
        
        const errorMsg = `The AI returned an unexpected data type that could not be processed. Raw output: ${JSON.stringify(output)}`;
        throw new Error(errorMsg);
    });
}

export async function convertQuestionsToJson(input: ConvertQuestionsToJsonInput): Promise<string> {
    return convertContentToJson(convertQuestionsToJsonPrompt, input);
}

export async function convertFlashcardsToJson(input: ConvertFlashcardsToJsonInput): Promise<string> {
    return convertContentToJson(convertFlashcardsToJsonPrompt, input);
}
