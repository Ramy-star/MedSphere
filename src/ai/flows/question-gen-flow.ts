
'use server';
/**
 * @fileOverview AI flows for the Questions Creator feature.
 *
 * - generateQuestions - Generates questions based on document content.
 * - convertQuestionsToJson - Converts text-based questions to a structured JSON format.
 * - repairJson - Attempts to repair a malformed JSON string.
 */

import { ai } from '@/ai/genkit';
import { z } from 'genkit';

// Schema for generating questions
const GenerateQuestionsInputSchema = z.object({
  prompt: z.string().describe('The user-defined prompt for generating questions.'),
  documentContent: z.string().describe('The text content extracted from the uploaded document.'),
  images: z.array(z.string()).describe("A list of images from the document, as data URIs. Expected format: 'data:<mimetype>;base64,<encoded_data>'."),
});
export type GenerateQuestionsInput = z.infer<typeof GenerateQuestionsInputSchema>;

// Schema for converting questions to JSON
const ConvertToJsonInputSchema = z.object({
  prompt: z.string().describe('The user-defined prompt for JSON conversion.'),
  questionsText: z.string().describe('The text of the questions generated by the first model.'),
});
export type ConvertToJsonInput = z.infer<typeof ConvertToJsonInputSchema>;

// Schema for repairing JSON
const RepairJsonInputSchema = z.object({
  malformedJson: z.string().describe('The malformed JSON string that needs to be repaired.'),
  desiredSchema: z.string().describe('A description or schema of the desired JSON structure.'),
});
export type RepairJsonInput = z.infer<typeof RepairJsonInputSchema>;


const generateQuestionsPrompt = ai.definePrompt({
    name: 'generateQuestionsPrompt',
    input: { schema: GenerateQuestionsInputSchema },
    prompt: `
        You are an expert at creating educational material from documents.
        Follow the user's instructions precisely to generate questions from the provided document content, which includes text and images.
        Base your questions on both the text and the visual information in the images.
        Use clear separators like '---' between different sections (e.g., between Level 1 MCQs and Level 2 MCQs).

        USER'S PROMPT:
        {{{prompt}}}

        DOCUMENT CONTENT (TEXT):
        {{{documentContent}}}

        DOCUMENT CONTENT (IMAGES):
        {{#each images}}
        {{media url=this}}
        {{/each}}
    `,
});

const isRetriableError = (error: any): boolean => {
    const errorMessage = error.message?.toLowerCase() || '';
    const retriableStrings = ['500', '503', '504', 'overloaded', 'timed out', 'service unavailable'];
    return retriableStrings.some(s => errorMessage.includes(s));
};

async function runWithRetry<T>(fn: () => Promise<T>): Promise<T> {
  const maxRetries = 3;
  let delay = 1000;

  for (let i = 0; i < maxRetries; i++) {
    try {
      return await fn();
    } catch (error: any) {
      if (i === maxRetries - 1 || !isRetriableError(error)) {
        console.error(`Final attempt failed or non-retriable error: ${error.message}`);
        throw error;
      }
      console.log(`Attempt ${i + 1} failed. Retrying in ${delay}ms...`);
      await new Promise(res => setTimeout(res, delay));
      delay *= 2;
    }
  }
  throw new Error('Operation failed after multiple retries.');
}

export async function generateQuestions(input: GenerateQuestionsInput): Promise<string> {
    return runWithRetry(async () => {
        const { text } = await generateQuestionsPrompt(input);
        return text;
    });
}

// Programmatic reordering to guarantee final structure
function reorderAndStringify(obj: any): string {
    const orderedKeys = ['id', 'name', 'mcqs_level_1', 'mcqs_level_2', 'written', 'flashcards'];
    const orderedObject: { [key: string]: any } = {};

    // Add known keys in the desired order
    for (const key of orderedKeys) {
        if (obj.hasOwnProperty(key)) {
            orderedObject[key] = obj[key];
        }
    }

    // Add any other keys that might exist (to prevent data loss)
    for (const key in obj) {
        if (!orderedObject.hasOwnProperty(key)) {
            orderedObject[key] = obj[key];
        }
    }
    
    // Ensure the key order within each MCQ object is correct
    const reorderMcqKeys = (mcqs: any[]) => {
      if (!Array.isArray(mcqs)) return mcqs;
      return mcqs.map(mcq => {
        if (typeof mcq !== 'object' || mcq === null) return mcq;
        const orderedMcq: {[key: string]: any} = {};
        if (mcq.hasOwnProperty('q')) orderedMcq.q = mcq.q;
        if (mcq.hasOwnProperty('o')) orderedMcq.o = mcq.o;
        if (mcq.hasOwnProperty('a')) orderedMcq.a = mcq.a;
        // Add any other keys to be safe
        Object.keys(mcq).forEach(key => {
          if (!orderedMcq.hasOwnProperty(key)) {
            orderedMcq[key] = mcq[key];
          }
        });
        return orderedMcq;
      });
    };

    if (orderedObject.mcqs_level_1) {
      orderedObject.mcqs_level_1 = reorderMcqKeys(orderedObject.mcqs_level_1);
    }
    if (orderedObject.mcqs_level_2) {
      orderedObject.mcqs_level_2 = reorderMcqKeys(orderedObject.mcqs_level_2);
    }
    if (orderedObject.flashcards) {
        if(Array.isArray(orderedObject.flashcards)) {
            orderedObject.flashcards = orderedObject.flashcards.map(fc => {
                if (typeof fc !== 'object' || fc === null) return fc;
                const orderedFc: {[key: string]: any} = {};
                if (fc.hasOwnProperty('front')) orderedFc.front = fc.front;
                if (fc.hasOwnProperty('back')) orderedFc.back = fc.back;
                Object.keys(fc).forEach(key => {
                    if (!orderedFc.hasOwnProperty(key)) {
                        orderedFc[key] = fc[key];
                    }
                });
                return orderedFc;
            });
        }
    }


    return JSON.stringify(orderedObject, null, 2);
}


const convertToJsonPrompt = ai.definePrompt({
    name: 'convertToJsonPrompt',
    input: { schema: ConvertToJsonInputSchema },
    output: { format: 'json' },
    prompt: `
        You are a text-to-JSON conversion specialist.
        Follow the user's prompt to convert the given text into a structured JSON format.
        Your output MUST be only the JSON itself, without any surrounding text or markdown.
        It is absolutely critical that you process the ENTIRE input text and include ALL questions in the final JSON. Do not truncate or partially convert the content.
        The order of keys inside each question object must be 'q', then 'o', then 'a'.

        USER'S PROMPT:
        {{{prompt}}}

        TEXT TO CONVERT:
        {{{questionsText}}}
    `,
});

export async function convertQuestionsToJson(input: ConvertToJsonInput): Promise<string> {
    return runWithRetry(async () => {
        try {
            const { output } = await convertToJsonPrompt(input);

            if (typeof output === 'object' && output !== null) {
                // Return the stringified JSON with guaranteed key order
                return reorderAndStringify(output);
            }
            
            // If the output is already a string, it might be malformed or correct.
            if (typeof output === 'string') {
                try {
                    const parsed = JSON.parse(output);
                    return reorderAndStringify(parsed);
                } catch(e) {
                     // If parsing fails, try to repair it.
                    console.warn("Initial JSON conversion produced a string that failed to parse. Attempting repair.");
                    const repairedJsonString = await repairJson({
                        malformedJson: output,
                        desiredSchema: "A JSON object with keys like 'id', 'name', 'mcqs_level_1', etc."
                    });
                    const parsedRepaired = JSON.parse(repairedJsonString);
                    return reorderAndStringify(parsedRepaired);
                }
            }
            
            const errorMsg = `The AI returned a response that could not be converted to a valid JSON structure. Raw output: ${JSON.stringify(output)}`;
            throw new Error(errorMsg);

        } catch (err: any) {
            console.error("Error in convertQuestionsToJson flow:", err.message);
            // Attempt to repair if there's a JSON string in the error
            if (input.questionsText) {
                try {
                     console.log("Attempting to repair JSON from original text due to error.");
                     const repairedJsonString = await repairJson({
                        malformedJson: input.questionsText, // Use original text as it might contain the broken JSON
                        desiredSchema: "A JSON object with keys like 'id', 'name', 'mcqs_level_1', etc."
                     });
                     const parsedRepaired = JSON.parse(repairedJsonString);
                     return reorderAndStringify(parsedRepaired);
                } catch (repairErr: any) {
                    console.error("JSON repair failed:", repairErr.message);
                    throw new Error("Failed to convert and repair the JSON content.");
                }
            }
            throw new Error(err.message || "An unexpected error occurred during JSON conversion.");
        }
    });
}


const repairJsonPrompt = ai.definePrompt({
    name: 'repairJsonPrompt',
    input: { schema: RepairJsonInputSchema },
    output: { format: 'json' },
    prompt: `
        You are a JSON repair expert. The following string is a malformed JSON.
        Fix it so that it perfectly matches the desired schema.
        The desired schema is: {{{desiredSchema}}}

        Malformed JSON:
        {{{malformedJson}}}

        Your response MUST be only the corrected JSON content.
    `,
});

export async function repairJson(input: RepairJsonInput): Promise<string> {
     return runWithRetry(async () => {
        const { output } = await repairJsonPrompt(input);
        
        if (typeof output === 'object' && output !== null) {
            return JSON.stringify(output, null, 2);
        }
        
        if (typeof output === 'string') {
            const trimmedOutput = output.trim();
            if ((trimmedOutput.startsWith('{') && trimmedOutput.endsWith('}')) || (trimmedOutput.startsWith('[') && trimmedOutput.endsWith(']'))) {
                return output;
            }
        }
        
        throw new Error('The repair process resulted in invalid or unexpected data type.');
    });
}

