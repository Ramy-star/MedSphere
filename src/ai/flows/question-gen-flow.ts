
'use server';
/**
 * @fileOverview AI flows for the Questions Creator feature.
 *
 * - generateQuestions - Generates questions based on document content.
 * - convertQuestionsToJson - Converts text-based questions to a structured JSON format.
 * - repairJson - Attempts to repair a malformed JSON string.
 */

import { ai } from '@/ai/genkit';
import { z } from 'genkit';

// Schema for generating questions
const GenerateQuestionsInputSchema = z.object({
  prompt: z.string().describe('The user-defined prompt for generating questions.'),
  documentContent: z.string().describe('The text content extracted from the uploaded document.'),
  images: z.array(z.string()).describe("A list of images from the document, as data URIs. Expected format: 'data:<mimetype>;base64,<encoded_data>'."),
});
export type GenerateQuestionsInput = z.infer<typeof GenerateQuestionsInputSchema>;

// Schema for converting questions to JSON
const ConvertToJsonInputSchema = z.object({
  prompt: z.string().describe('The user-defined prompt for JSON conversion.'),
  questionsText: z.string().describe('The text of the questions generated by the first model.'),
});
export type ConvertToJsonInput = z.infer<typeof ConvertToJsonInputSchema>;

// Schema for repairing JSON
const RepairJsonInputSchema = z.object({
  malformedJson: z.string().describe('The malformed JSON string that needs to be repaired.'),
  desiredSchema: z.string().describe('A description or schema of the desired JSON structure.'),
});
export type RepairJsonInput = z.infer<typeof RepairJsonInputSchema>;


const generateQuestionsPrompt = ai.definePrompt({
    name: 'generateQuestionsPrompt',
    input: { schema: GenerateQuestionsInputSchema },
    prompt: `
        You are an expert at creating educational material from documents.
        Follow the user's instructions precisely to generate questions from the provided document content, which includes text and images.
        Base your questions on both the text and the visual information in the images.

        USER'S PROMPT:
        {{{prompt}}}

        DOCUMENT CONTENT (TEXT):
        {{{documentContent}}}

        DOCUMENT CONTENT (IMAGES):
        {{#each images}}
        {{media url=this}}
        {{/each}}
    `,
});

const isRetriableError = (error: any): boolean => {
    const errorMessage = error.message?.toLowerCase() || '';
    const retriableStrings = ['500', '503', '504', 'overloaded', 'timed out', 'service unavailable'];
    return retriableStrings.some(s => errorMessage.includes(s));
};

async function runWithRetry<T>(fn: () => Promise<T>): Promise<T> {
  const maxRetries = 3;
  let delay = 1000;

  for (let i = 0; i < maxRetries; i++) {
    try {
      return await fn();
    } catch (error: any) {
      if (i === maxRetries - 1 || !isRetriableError(error)) {
        console.error(`Final attempt failed or non-retriable error: ${error.message}`);
        throw error;
      }
      console.log(`Attempt ${i + 1} failed. Retrying in ${delay}ms...`);
      await new Promise(res => setTimeout(res, delay));
      delay *= 2;
    }
  }
  throw new Error('Operation failed after multiple retries.');
}

export async function generateQuestions(input: GenerateQuestionsInput): Promise<string> {
    return runWithRetry(async () => {
        const { text } = await generateQuestionsPrompt(input);
        return text;
    });
}


const convertToJsonPrompt = ai.definePrompt({
    name: 'convertToJsonPrompt',
    input: { schema: ConvertToJsonInputSchema },
    output: { format: 'json' },
    prompt: `
        You are a text-to-JSON conversion specialist.
        Follow the user's prompt to convert the given text into a structured JSON format.
        Your output MUST be only the JSON itself, without any surrounding text or markdown.

        USER'S PROMPT:
        {{{prompt}}}

        TEXT TO CONVERT:
        {{{questionsText}}}
    `,
});

export async function convertQuestionsToJson(input: ConvertToJsonInput): Promise<string> {
    return runWithRetry(async () => {
        try {
            const { output } = await convertToJsonPrompt(input);

            if (typeof output === 'object' && output !== null) {
                // Return the stringified JSON with formatting to preserve newlines.
                return JSON.stringify(output, null, 2);
            }
            // If the output is already a string, assume it's a correctly formatted JSON string.
            if (typeof output === 'string') {
                // Basic validation to ensure it's likely JSON without re-parsing.
                const trimmedOutput = output.trim();
                if ((trimmedOutput.startsWith('{') && trimmedOutput.endsWith('}')) || (trimmedOutput.startsWith('[') && trimmedOutput.endsWith(']'))) {
                    return output;
                }
            }
            
            const errorMsg = `The AI returned a response that could not be converted to a valid JSON structure. Raw output: ${output}`;
            throw new Error(errorMsg);

        } catch (err: any) {
            console.error("Error in convertQuestionsToJson flow:", err.message);
            throw new Error(err.message || "An unexpected error occurred during JSON conversion.");
        }
    });
}


const repairJsonPrompt = ai.definePrompt({
    name: 'repairJsonPrompt',
    input: { schema: RepairJsonInputSchema },
    output: { format: 'json' },
    prompt: `
        You are a JSON repair expert. The following string is a malformed JSON.
        Fix it so that it perfectly matches the desired schema.
        The desired schema is: {{{desiredSchema}}}

        Malformed JSON:
        {{{malformedJson}}}

        Your response MUST be only the corrected JSON content.
    `,
});

export async function repairJson(input: RepairJsonInput): Promise<string> {
     return runWithRetry(async () => {
        const { output } = await repairJsonPrompt(input);
        
        if (typeof output === 'object' && output !== null) {
            return JSON.stringify(output, null, 2);
        }
        
        if (typeof output === 'string') {
            const trimmedOutput = output.trim();
            if ((trimmedOutput.startsWith('{') && trimmedOutput.endsWith('}')) || (trimmedOutput.startsWith('[') && trimmedOutput.endsWith(']'))) {
                return output;
            }
        }
        
        throw new Error('The repair process resulted in invalid or unexpected data type.');
    });
}
